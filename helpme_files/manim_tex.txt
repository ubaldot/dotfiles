TEX
.get_parts_by_text(A) # returns a list
.tex_strings # Return a list that shows how the equation has been partitioned

print(mob.tex_strings)


Classic: separate pieces by comma
     t = mn.MathTex(
         rf"(y-{ii})",
         r"^2+",
         f"(y-{ii})",
         r"+1 = 0,",
         r"{{(y-a)}}^3-3{{(y-a)}}=1",
     )

- Here you have t[0], t[1], where each index point to string passed and
comma-separated. Then, each element is a letter because a string is a list
of letters in Python.
- For example t[2][4] is the fifth letter of the third string, in this case
"i". etc.

- If you don't comma separate, then you only have t[0] and then each character is
t[0][0], t[0][1], t[0][2], ...
- Each of t[i] is a SingleStringMathTex instance.

- If you have one long string either in Text/Tex/MathTex, you can get a
  pointer only to what you need with search_shapes_in_text:

        numbers = [3.5, -11.8]
        my_vec = MathTex(
            r"\mathbf{MyVec}= \begin{pmatrix} %s \end{pmatrix}"
            % " & ".join([str(n) for n in numbers])
            ).to_corner(DR, buff=1)
        myvec = group_shapes_in_text(my_vec, MathTex(r"\mathbf{MyVec}"))
        number1 = group_shapes_in_text(my_vec, MathTex(str(numbers[0])))
        number2 = group_shapes_in_text(my_vec, MathTex(str(numbers[1])))

- Note that \math* is changed to \sym*, e.g. \mathbf{} becomes \symbf{}, see
  unicode-math LaTeX package for more info.

- For the text, then you have \textbf{} can be replaced with \FSBlack{}, see
  myconfig

Use

    self.add(
            t.copy()
            .get_parts_by_tex(f"(y-{ii})")
            .next_to(t, mn.DOWN, aligned_edge=mn.LEFT)
        )

# Allowed values for substrings_to_isolate arguments must be any SingleStringMathTex that are present in t.tex_strings

# Tex() VS MathTex() VS tex_environment.
# Tex() is equivalent to
    \begin{document}
    \begin{center}
    % strings passed to Tex() go here
    \end{center}
    \end{document}

# MathTex() is equivalent to
    \begin{document}
    \begin{align}
    % strings passed to MathTex() go here
    \end{align}
    \end{document}

# If you don't want align or center, but e.g. tabular or figure, you pass in the
# tex_environment argument of Tex.
# e.g. Tex(r"pippo", tex_environment="{tabular}{|p{2cm}|p{2cm}|}") returns:

\begin{document}
\begin{tabular}{|p{2cm}|p{2cm}|}
% strings passed to Tex() go here
\end{tabular}
\end{document}

# Tables are mess. Manim is not super, better making them in LaTeX.
# But you cannot set colors in LaTeX, you have to do it in Manim.
# Also, you have to tell Manim which environment you are using.

template = mn.TexTemplate()
template.add_to_preamble(r"\def\arraystretch{1.5}")

t = mn.Tex(
    r"Qualitative name & Index or sub-index  & \multicolumn{4}{|c|}{Pollutant (hourly) concentration $[\mu g/m^3$]} \\"
    r"\hline ",
    r" && $NO_2$ & $PM_{10}$ & $O_3$ & $PM_{2.5}$ \\",
    r"\hline ",
    r"Very low", # This is t[4]
    r"& 0-25 & 0-50 & 0-25 & 0-60 & 0-15 \\",
    r"Low",
    r"& 25-50 & 50-100 & 25-50 & 60-120 & 15-30 \\",
    r"Medium",
    r"& 50-75 & 100-200 & 50-90 & 120-180 & 30-55 \\",
    r"High",
    r"& 75-100 & 200-400 & 90-180 & 180-240 & 55-110 \\",
    r"Very High",
    r"& $>100$ & $>400$ & $>180$ & $>240$ & $>110$ \\",
    tex_template=template,
    tex_environment="{tabular}{|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}",
).scale_to_fit_width(12)


# This is insane, you should check which part is rendered.
mn.VGroup(t[3][2:9]).set_color(mn.TEAL)
mn.VGroup(t[5][:3]).set_color(mn.GREEN)
mn.VGroup(t[6][-2:], t[7][:4]).set_color(mn.ORANGE)
mn.VGroup(t[8][-4:]).set_color(mn.RED)
mn.VGroup(t[10][-6:], t[11][:2]).set_color(mn.PURPLE)

Matrices
    dns = VGroup(*[DecimalNumber(val, num_decimal_places=1).scale(0.5) for val in [3.2, 0.8]])
    template = TexTemplate()
    template.add_to_preamble(r"\newenvironment{mymatrix}{\begin{equation*}\begin{pmatrix}}{\end{pmatrix*}\end{equation}}")
    my_vec = Tex(
            f"{dns[0].get_value()} & ",
            f"{dns[1].get_value()}",
            tex_environment="mymatrix",
            tex_template=template
            )
    self.add(my_vec)
